Memdb
=====

# Description

**Memdb** is a multi-platform tool for debugging heap memory usage. It consists of a server and a client part.

The server is a lightweight component written in the Rust programming language that can be easily linked to an existing Rust project. It starts a web socket to report realtime statistics about dynamic memory allocations and deallocations. This approach is convenient for debugging applications running on mobile or internet-enabled embedded devices. The server adds a hook to the Rust memory allocator that is invoked by all allocations and deallocations.

The client is a command-line tool that connects to the server and captures the stream of heap operations from the socket connection. The client is a JVM application written in Kotlin. The client can capture, visualise, and load/store the memory trace generated by the server.

The captured heap operations can then be further analyzed in the client tool. There are several commands to investigate the behaviour of the heap over time.

# Getting Started

## Environment setup

**MemDB** consists of a client and a server. The applications are written in different programming languages and require separate environment setups. They can be compiled and installed independently.

### Server

* Install Rust (1.91.1)

Use your favorite package manager to install Rust. The project was tested with 1.91.1.

To build the application, start:

```bash
cargo build
```

### Client

Perform the following steps to prepare your environment for building the client:

* Install JVM 21
* Install Kotlin 2.2.21
* Gradle (correct version ill be installed by running gradle wrapper)

The client application targets JVM 21. To compile the project it is important to first download and install JVM 21.

Installing the required version of Gradle can be done by invoking the Gradle Wrapper as follows:

```bash
./gradlew build
```

You can use your favourite package manager, such as `apt` or `brew`, to install the correct Kotlin package.

### Common

The following components are required for both the client and the server.

* Google protobuf-c (stable 1.5.2)

You can use your favourite package manager, such as `apt` or `brew`, to install the correct package.

## Dependencies

The client dependencies are listed in client/gradle/libs.version.toml.

The server depends on the following Rust crates:

* backtrace (0.3)
* gettid (0.1.4)
* protobuf (3.7.2)
* time (0.3.44)

Building the client can be done by invoking the gradle wrapper with the build command:

```bash
 ./gradlew build
 ./gradlew uberJar
```

The client can be started by running:

```bash
./memdb.sh
```

It might be convenient to create a 'memdb' alias that executes the script. This can be done as follows:

```bash
alias memdb='<<path to memdb.sh>>'
```

 The script forwards its command line arguments to the client application. To get help about the command line options the -h option can be specified.

```bash
./memdb.sh -h
```

## Instrumenting your application

The first step is to instrument the Rust application that you want to analyze. This works by importing the server library from the memdb crate in your application and using the instrumented allocator. 

The server contains several small example programs to demonstrate how to instrument your application. The following is a fairly minimal example showing how to instrument your applicationis:

```rust
fn main() {
    let server_thread = memdb_lib::server::run_with_default_address().unwrap_or_else(|error| {
        println!("Unable to run server on default address: {error:?}");
        process::exit(-1);
    });
    my_application();
    memdb_lib::server::send_terminate();
    server_thread.join().unwrap_or_else(|error| {
        println!("Unable to join server thread: {error:?}");
        process::exit(-1);
    });
}
```

In the example above, `run_with_default_address` starts the server thread and waits on the default local host address. Next, the main application function, where the heap operations are performed, is called. The server will send the information about the heap operations to the client using a socket connection. Finally, a terminate message is sent to the server using the `send_terminate` function. When the sever thread receives this message, it will  exit its main loop. At that point the application can call join on the server thread and the application can close.

## Executing program

When running the instrumented application you will get the following console output:

```bash
Waiting for connection...
Server thread started!
```

The application will then wait for the client to connect. By default, the server will run on localhost at port 8989, but this can be configured.

To connect the client to the memdb server you can run:

```bash
memdb --capture [ip]:[port]
```

Where ip is the IP address where the server application is running. It can be localhost when client and server run on the same machine, but it can also be the IP address of another system, such as a mobile device or game console.

When the client is connected, the user application will continue execution and the memdb client will start collecting memory applications. 

## Documentation

The client is documented using KDoc. The Dokka Gradle plugin is used for generating documentation. It can be invoked using:

```bash
/gradlew build dokkaGenerateHtml
```

HTML documentation will be generated in the build/dokka directories.

## Troubleshooting

### Incorrect JVM version

Run the following command to verify that the correct JVM is installed:

```bash
% javac --version
javac 21.0.8
```

The output should indicate that JVM 21 is used. Check that your `JAVA_HOME` path is correctly specified.

```bash
% javac --version
javac 21.0.8
```

## Authors

** Developer: ** * Arjan Janssen *
Contact: arjan.janssen@gmail.com

## Version History

* 0.0
** Work in progress towards initial release

## License

This project is licensed under the FreeBSD License - see LICENSE.md for details.

## Future work

* Handle long label widths for graph plotting
* Backtrace should be truncated to only show relevant functions
* Labels with spaces should be supporting syntax such as "my label".."your label" for diffs.
* Add support for command history in the interactive mode - using arrow up to show previous commands.
* Setting default settings (columns, rows, etc) in a configuration file.
* Added a bt command for only printing the backtrace of an operation.
* Add a markers command that shows all the markers in the tracked heap.
* Handle empty tracked heaps more gracefully.

## Acknowledgements

This project was inspired by the article https://www.gamedeveloper.com/game-platforms/monitoring-your-console-s-memory-usage-part-one

I started this project to familiarize myself with modern programming languages Rust and Kotlin.

My intial plan was to go for a fairly minimum toy application. However, the project inspired me and it became a functional command line tool that perhaps can also help other people in analyzing heap usage.
